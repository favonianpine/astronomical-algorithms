第5章 迭代


  迭代(英语Iteration译为迭代，来自拉丁语 Iterare = 重复)是一种“重复计算数次，直到未知量算出为止”的方法。通常，在每次重复计算后，结果将更接近正确解。我们已经看到，第3章中，解方程(3.6)、(3.7)、(3.9)、(3.10)、(3.11)时已经使用了迭代方法。

  当找不到直接的容易的方法求解未知量时，可以考虑使用迭代法。例如：

·五次方程：x5 + 17x - 8 = 0

·对于给定的地表上的某一位置，计算日食(或月亮对恒星的星食)的起止时刻

·求解开普勒方程E=M+e*sin(E)(见第29章)，式中E是未知量。

  执行一次迭代，为了取得更好的未知量结果，需要未知量的起始估计值，并代入一个迭代公式或公式组。重复这一过程(即迭代)，直到达到了所需的精度。

  一个古的例子是，计算一个数的平方根，计算过程如下。当然，今天，我们可能对此失去兴趣（除了某些特殊情况），因为所有的珍袖计算器及所有的计算机语言都含有开方函数。

  设我们要对N进行开方，其开方根的初始估值是n，如果无法知道初始估值，不妨取1。算出N/n与n的算术平均值，那么开方根的更好的估值是(n+N/n)/2。然后重复上述计算。

-------------------------

例5.a：计算sqrt(159)，取8位有效数字。

  我们知道12*12=144，所以可以用12作为sqrt(159)的估值。用159除12，得到13.2500。那么12与13.2500的算术平均值是12.6250，这就是更好的估值。

  我们现在用159除12.6250，得到12.59406，12.59406与12.6250的平均值是12.60953，这个值将更准确了。

  依这种方法，我们依次得到：

  12 = 开始值
  12.62500000
  12.60952971
  12.60952022
  12.60952022

  我们看到12.60952022到12.60952022已不再变化，所以这就是159的平方根。

-------------------------------

例5.b：计算以下方程的真根。

  x5 + 17x - 8 = 0    (5.1)

  因为5次方程的根，没有直接解法或公式可以使用，我们求助迭代法。在方程(5.1)中，我们反x的5次方移到方程右边，得到：

  x = (8 - x5)/17    (5.2)

  现在，方程右边也含有未知量x，但不要紧，我们看到，用 x = 0 作为初值代入右边，公式(5.2)得到：

  x = 8/17 = 0.470 588 235

  此值，已经比x=0要准确了。现在，我们把x=0.470588235再次代入方程右边，得到x=0.469230684。在4次迭代后，我们得到确定值，即x=0.469249878。

---------------------------------

  然而，迭代法并不总是没有问题，以下用一个例子说明。

例5.c：考虑方程 x5 + 3x - 8 = 0

  和前面的例子一样，把x5移到方程右边，得到：

  x = 8 - x5

  从 x = 0 开始，我们依次得到：

0.0000(开始值)
2.6667
-42.2826
45049099
-6.18*1037
等等...

可见，在这种情况下，此方法不能正常工作。结果是无穷大，其绝对值越变越大，走向错误的方向。

--------------------------------

  为什么这种方法适用于“例5.b”，而不适用于“例5.c”？当x在0到1之间，x^5也在0到1之间，并且x^5小于x，这就是“例5.b”逐次迭代能够收敛于一个明确数值(方程的根)的原因。这个根在0到1之间。

  但是，我们看到，例5.c方程的根大于1。当x>1时，x^5>x>1(如x=2，则有x^5=32)，x微小的变化，将引起x^5很大的变化。因此，执行与“例5.b”相同的方法却不能收敛于所需的结果，逐次迭代的结果是发散的。然而，如果我们把迭代公式改写为其它形式，仍然可以得到答案。

----------------------------

例5.d：让我们再次考虑方程 x^5+3x-8=0，但是，我们考虑这个事实，方程的根大于1，x^5>x。因此，我们不能把x^5直接移到方程的右边。相反，我们把x^5保留在方程的左边，所以方程变为：

  x5 = 8 - 3x 或 x = 5√ 8 - 3x 

  初始取x=0，通过14次迭代后，我们得到方程的根为 x = 1.321785627。

---------------------------------

  在例5.b中，我们寻找方程的根：

  x5 + 17x - 8 = 0

  然而，我们可以改写方程为：

  x(x4+17) = 8，因此 x = 8/(x4+17)

  我们现在可能使用最后这个式子代替(5.2)式。做为一个例子，你可以用迭代法解这个方程，你将得到与“例5.b”相同的结果。

  如果我们希望使用同样的方法处理“例5.C”的方程，可以得到以下迭代算式：

  x = 8/(x4+3)

  用 x = 0 做为初始值代入方程右边，得到x=8/3=2.666...。我们将惊喜地发现：几次迭代之后，结果很快的由2.666223459变到0.149436927。由此，我们看到，并不是所有情况下都能迭代成功，它依赖于迭代公式。

  再来看一个例子，考虑方程：sinφ=3cosφ。把φ=0°代入方程的右边，得到sinφ=3，显然不合理。相反，用φ=90°代入方程右边，得到sinφ=0，从而得到φ=0°，如此继续迭代，则又回到了第一种情况案。

  但是，如果我们把方程改写为cosφ=(sinφ)/3，用φ=0°起步，几次迭代后最后将得到φ=71°.565051。

  或者，考虑一下方程sinφ=cos2φ。解为30°，因为sin 30° = cos 30°。如果我们用φ=29°代入方程右边，我们发现之后的迭代是发散的。但是，如果方程改写为cos2φ=sinφ，那么迭代是收敛的。

  为了进一步说明迭代过程，让我们考虑一下含单一未知量方程的牛顿寻根法。

  设f(x)是关于x的函数，我们要求解f(x)=0时x的值。设f'(x)是f(x)的导函数。如果xn是方程根的估值，然后计算出f(x)的函数值yn以及相应的导函数f'(x)值yn'，其中，yn'是曲函数曲线在xn点的切线的斜率，详见下图。那么，方程根的更好估值是：

  xn+1 = xn - yn/y'n



  然后，用这个新的估值重复计算，直到x达到所需的值。

  在这一过程中，选择良好的起步x值，是个关键问题。例如，方程 x5 - 3x - 8 = 0，其导函数是 5x4 - 3，如果起步值取 x = 0，我们将得到以下摆动值：

 0.000 000 000
-2.666 666 667
-2.126 929 222
-1.672 392 941
-1.227 532 073
-0.376 965 299
-2.749 036 974
-2.194 266 642
-1.731 201 846
-1.293 218 530
-0.588 844 800
-3.216 865 068
-2.572 967 057
-2.049 930 313
-1.603 831 482
-1.145 086 797

  原因是，函数在x=-0.88时达到最大值，所以，在该点两边，其切线的斜率方向是相反的。

  但是，如果起步值使用x=1，那么通过11次迭代后，即可得到9位有效数它的正确值。

+1.000 000 000
+6.000 000 000
+4.803 458 391
+3.850 111 311
+3.095 824 107
+2.510 476 381
+2.080 081 724
+1.807 461 730
+1.690 945 284
+1.671 102 262
+1.670 579 511
+1.670 579 156
+1.670 579 156

-----------------------------------

用“小于”判断结果

  以上描述的迭代方法——重复计算，直到结果不再变化。换句话说，只要最后一个结果与上一个结果不同，新的迭代就必须继续执行。但由于计算机本身有截断误差，这样做会有点问题。

  考虑以下3次方程：s3 + 3s - W = 0

  该式用于抛物线轨道计算(详见第33章)。式中，W一个给定的常数，而s是未知量。这个方程可以很容易地使用迭代法求解。用任意值起步，一个良好的选择是s=0，然后，s更好的值是：

  (2s3 + W) / [3(s2+1)]

  经过几次迭即可获得正确结果。比较，取W=0.9，在HP-85微机上执行，依次得到以下结果：

0.000 000 000 000
0.300 000 000 000
0.291 743 119 266
0.291 724 443 641
0.291 724 433 546
0.291 724 433 548
0.291 724 433 548

  因此，12位有效数字的精确结果是0.291724443548。但是，当W=1.5时，在同样的微机上执行，我们惊的发现：程序不会停止，结果如下：

0.000 000 000 000
0.500 000 000 000
0.466 666 666 667
0.466 220 600 162
0.466 220 523 909
0.466 220 523 911
0.466 220 523 910
0.466 220 523 908
0.466 220 523 911
0.466 220 523 910
0.466 220 523 908

  永远重复着：...911，...910，...908。然而，同相的计算，我们拿到另外两种计算机上执行，迭代过程却是收敛的，可换个W的值，又不敛了。

  这个问题的补救方法：用“小于”代替代“等于”来判断是否继续迭代。即，如果新迭代结果与上一次结果之差的绝对值，小于某个给定值(如10^-10)，就停止迭代。

　

二分法

  这是一种绝对可靠的方法，因为它既不会失控也不会发散，总会收敛于计算机所能达到的最高精度的一个确值。这种方示不必寻找“下一个更佳的根的表达式”，它仅使用“二分查找”确定方程的根。

  让我们重新考虑“例5.b”的方程x^5+17x-8=0，并借此阐述二分法。

  当x=0和x=1时，方程左边的值分别是-8和+10。所以我们知道，方程的根介于0到1之间。

  现在，让我们偿试x=0.5，它是0和1的算术平均值。当x=0.5时，函数值为+0.53125，它与x=0时的函数值的符号相反，所以，现在我们知道，方程的根介于0到0.5（注1）。

  ［注1：只有在连续区间才是正确的。如，tan86°>0和tan93°<0，我们无法在86°与93°之间确定tan(x)=0时的x的值。］

  我们再偿试x=0.25，它时0和0.25的算术平均值。其余类推。

  每执行一步，根所在的区间减小一半。32步之后，将得到很高的精度。在“例5.b”中，获得同样的精度仅需6步，但是，我们已经指出，二分法是绝对安全的，在“普通”迭代法失效的情况下它也可能使用。

  对于二分法，我们知道，前进n步后的精度是：初始区间宽度除以2n

  以上的那个例子，用二分法求解的BASIC程序如下。其中第60行并不是真正需要的，它展示了x逐步逼近的过程。

 10 DEF FNA(X) = X*(X^4+17)-8
 20 X1 = 0 : Y1 = FNA(X1)
 30 X2 = 1 : Y2 = FNA(X2)
 40 FOR J=1 TO 33
 50 X = (X1+X2)/2
 60 PRINT J,X
 70 Y = FNA(X)
 80 IF Y=0 THEN PRINT J,X : END
 90 IF Y*Y1>0 THEN 120
100 X2 = X : Y2 = Y
110 GOTO 130
120 X1 = X : Y1 = Y
130 NEXT J
140 END
